# ME6104 Computer-Aided Design Project
#
# Bezier Visualizations

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from scipy.special import comb

def set_axes_equal(ax):
    """ Make axes of 3D plot have equal scale so that spheres appear as spheres,
        cubes as cubes, etc..  This is one possible solution to Matplotlib's
        ax.set_aspect('equal') and ax.axis('equal') not working for 3D.

        Input:
            ax: a matplotlib axis, e.g., as output from mplot3d.Axes3D(fig)
    """
    # Define Current Axes Limits
    x_limits = ax.get_xlim3d()
    y_limits = ax.get_ylim3d()
    z_limits = ax.get_zlim3d()

    # Calculate Scaling
    x_range = abs(x_limits[1] - x_limits[0])
    x_middle = np.mean(x_limits)
    y_range = abs(y_limits[1] - y_limits[0])
    y_middle = np.mean(y_limits)
    z_range = abs(z_limits[1] - z_limits[0])
    z_middle = np.mean(z_limits)

    # The plot bounding box is a sphere in the sense of the infinity
    # norm, hence I call half the max range the plot radius.
    plot_radius = 0.5*max([x_range, y_range, z_range])

    # Set New Axes Limits
    ax.set_xlim3d([x_middle - plot_radius, x_middle + plot_radius])
    ax.set_ylim3d([y_middle - plot_radius, y_middle + plot_radius])
    ax.set_zlim3d([z_middle - plot_radius, z_middle + plot_radius])


# Generate num number of discrete points
def gen_mesh(num):
    u = np.empty(num)
    for i in range(num):
        u[i] = i * (1 / (num - 1))
    return u


# Generate Bernstein coefficients for a set of discrete points for one k
def bernstein_poly(u, k, n):
    poly = np.empty(np.size(u))
    for i, j in enumerate(u):
        poly[i] = comb(n, k) * (j ** k) * (1 - j) ** (n - k)
    return poly


# Determine surface using num_u * num_v set of discrete points and cp control points
def bezier_surface(cpp, num_u, num_v):
    u = gen_mesh(num_u)
    v = gen_mesh(num_v)
    dim = np.size(cpp, 0)
    n_u = np.size(cpp, 1)
    n_v = np.size(cpp, 2)
    n = n_u * n_v
    poly = np.zeros((dim, num_u, num_v))
    for coord in range(dim):
        for i in range(n_u):
            for j in range(n_v):
                # Degree of polynomial one less than number of control points
                poly[coord] = poly[coord] + np.outer(bernstein_poly(u, i, n_u - 1), bernstein_poly(v, j, n_v - 1)) * \
                              cpp[coord][i][j]
    return poly


# Add surface to figure
def plot(cpp, num_u=100, num_v=100):
    print("Plotting Surface...")
    fig = plt.figure()
    fig.suptitle("Surface Generated by Genetic Algorithm")
    surface = bezier_surface(cpp, num_u, num_v)
    ax = fig.add_subplot(111, projection="3d")
    ax.plot_surface(X=surface[0], Y=surface[1], Z=surface[2])
    set_axes_equal(ax)
    plt.show()
